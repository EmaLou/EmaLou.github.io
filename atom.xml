<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[EmaLou's Blog]]></title>
  <link href="http://emalou.me/atom.xml" rel="self"/>
  <link href="http://emalou.me/"/>
  <updated>2015-02-10T23:15:49+08:00</updated>
  <id>http://emalou.me/</id>
  <author>
    <name><![CDATA[EmaLou]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    
    <title type="html"><![CDATA[JavaScript实现的日期验证]]></title>
    <link href="http://emalou.me/blog/2015/02/10/date-validation/"/>
    
    <updated>2015-02-10T23:08:40+08:00</updated>
    <id>http://emalou.me/blog/2015/02/10/date-validation</id>
    
    <content type="html"><![CDATA[<p>项目需要，最近在用angular做各种validation。</p>

<hr />

<h3>日期验证</h3>

<p>这里分享一个日期验证。</p>

<p>github地址：<a href="https://github.com/EmaLou/date-validation">https://github.com/EmaLou/date-validation</a></p>

<p>看页面(有点丑)：<a href="http://emalou.me/date-validation/">http://emalou.me/date-validation/</a></p>

<p>为什么用js，不用高大上的angular？</p>

<p>因为简单的js复用性高。只包含了验证是否为合法日期的代码，比较基础，可以cover大部分通用情况。</p>

<h3>禁止用户输入大于12的月份</h3>

<p>其实日期验证的功能，有很多特性可以加，比如<strong>禁止用户输入大于当年年月的日期</strong>，用angular的watch方法就很容易实现</p>

<pre><code>.directive('validateMonth', function () {
    return function (scope, element, attrs) {
    scope.$watch(attrs.ngModel, function(newValue, oldValue) {
        if (!newValue) {
            return;
        }
        if (newValue &gt; 12) {
            scope.customerDetail.month = oldValue;
        }
    })
    };
})
</code></pre>

<p>在directive上添加watch事件，可以禁止用户输入限定条件之外的内容。原理也很简单，当超过限制条件后，用旧的value替换新的value。</p>

<p>替换速度很快，肉眼不可见，就达到了“禁止输入”的效果。</p>

<h3>其它功能</h3>

<p>还有一些跟日期输入有关的效果，类似onblur的时候自动补全0，输入两个数字后自动跳到下一个input输入框，不管使用jquery还是angular都很容易实现，此处不再赘述。</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[一些关于Java异常处理的概念]]></title>
    <link href="http://emalou.me/blog/2014/12/18/talk-about-java-exception/"/>
    
    <updated>2014-12-18T00:38:45+08:00</updated>
    <id>http://emalou.me/blog/2014/12/18/talk-about-java-exception</id>
    
    <content type="html"><![CDATA[<h3>一： 基本概念</h3>

<p><strong>“Java中的基本概念是：结构不佳的代码不能运行.” </strong>—— 《Java编程思想》</p>

<p>“异常”这个词有“对此感到意外”的意思，异常处理需要处理的部分也正是没有按照预期想法运行的代码。</p>

<p>但是出现错误的地方不一定知道如何处理错误，当前环境中也许没有足够的信息来解决这个“意外”，于是将错误提交到高级别的环境中，从而做出正确的决定。这就是抛出异常。</p>

<p>我们常用 try..catch 块来抛出和处理异常</p>

<pre><code>try{
    // Code that might generate exceptions
}catch {
   // Handle exceptions
}
</code></pre>

<p>根本目的是为了将完成任务的代码和错误检查的代码相互分离开，同时可以处理异常。</p>

<p>说道异常处理，理论上有两种基本模型，<strong>终止模型&amp;恢复模型。</strong></p>

<p>Java支持<strong>终止模型</strong>，这种模型中，当错误发生的时，假设错误十分关键，以至程序无法返回到异常发生的地方继续执行，一旦异常被抛出，就表明错误无法挽回，不能回来继续执行代码。</p>

<p><strong>恢复模型</strong>则认为异常处理程序的工作是修正错误，然后重新尝试try块的代码，并认为下一次能成功。如果希望java实现类似恢复的行为，那么再遇见错误的时候不能抛出异常，而是调用方法修正错误，或将try放在while循环中不断执行，直到结果满意。</p>

<p>但是恢复模型不实用，因为恢复模性的处理程序需要知道异常抛出的地点，对于异常会从很多地方抛出的大型程序而言，很难实现和维护。</p>

<p>那么有办法改良从而使恢复模型变得实用吗？</p>

<p>当然有，把try放进while循环里时设置一个static类型的计数器，使循环在放弃以前能尝试一定的次数，这将使程序的健壮性提高很多。</p>

<p>我们经常在异常处理代码看到下面这个东东：</p>

<pre><code>catch(Exception e) {
    e.printStackTrace();
}
</code></pre>

<p>printStackTrace() 方法将打印“从方法调用处直到异常抛出处”的方法调用序列，也就是栈轨迹。从这里可以看到异常是如何被一层层抛出，都经过了哪些方法。</p>

<p>以上异常都是在try..catch抛出，称为“被检查的异常”，编译时期强制检查。除此之外，还有一种“不受检查的异常”，在代码运行时自动检查，称为RuntimeException。</p>

<p>比如NullPointerException，如果在java代码中对每一个对象都检查是否为空，开销未免太大，Java虚拟机便帮我们做了这样一个检查，运行时发现为空的对象时，由Java虚拟机自动抛出异常。</p>

<p>那么问题来了，如果只抛出没有人捕获这个异常的话会发生什么？</p>

<p>答案是：如果RuntimeException没有被捕获而直达main()，那么在程序退出前将调用异常的printStackTrace()方法讲堆栈信息打印出来。</p>

<p>异常处理的最后，finally处理那些不管发生什么都一定要被执行的代码。</p>

<h3>二：编写简单的自定义异常</h3>

<p>在我们的代码中，如何使用异常呢。</p>

<p>首先需要了解，Exception是java中所有异常类的基类，继承自Throwable。</p>

<p>如果我们需要抛出的异常类能够承载一些信息，那么就需要自定义异常类，并在恰当的时候抛出，而非每次都抛出Exception类。</p>

<p>如果可以用自定义异常解决问题，那么Exception类还有用吗？
答案是非常有用，看下面的例子。</p>

<pre><code>public void dataAccessCode(){
    Connection conn = null;
    try{
        conn = getConnection();
    }catch(SQLException ex){
        ex.printStacktrace();
        // Handle the exception
    }catch(Exception e) {
        e.printStacktrace();
    } finally{
        DBUtil.closeConnection(conn);
    }
}
</code></pre>

<p>假设try中的代码抛出很多异常，异常处理时首先catch住SQLException，就会优先处理这个异常。</p>

<p>异常处理过程跟switch-case很相似，不同的是，每当catch住一个异常后就会执行该处的异常处理代码，之后异常处理过程结束。而switch-case中需要在每一个case后添加break语句，防止遍历case语句。</p>

<p>每个异常处理块只会在抛出的异常跟catch中的异常匹配时执行，如果catch中的所有异常都不匹配，而代码又确实抛出了异常，此时catch到Exception的代码就可以工作了。</p>

<p>所以通常在异常处理的最后加上对Exception的catch，防止漏掉某些异常。</p>

<p>那么如何编写自定义异常类呢，下面的例子是最常见的一种做法。</p>

<pre><code>public class AccountNotFoundException extends Exception {
    public AccountNotFoundException() {
        super();
    }
    public AccountNotFoundException(String message) {
        super(message);
    }
}
</code></pre>

<p>为自定义异常类添加构造方法，抛出异常类时候添加message，使异常承载更多的信息。</p>

<pre><code>throw new AccountNotFoundException("User");
// In different place
throw new AccountNotFoundException("Customer");
</code></pre>

<p>上面这两个异常被抛出，在异常的catch可以清楚的知道是哪种Account找不到。</p>

<p>如果为异常类添加私有变量和getter方法，如下：</p>

<pre><code>public class AccountNotFoundException extends Exception {
    private String message;
    public AccountNotFoundException() {
        super();
    }
    public AccountNotFoundException(String message) {
        super(message);
    }
    public String getMessage(){
        return this.message;
    }
}
</code></pre>

<p>那么对于不同地方抛出的异常，catch部分就可以根据不同的message而分别处理，如下：</p>

<pre><code>try{
    //throw AccountNotFoundException
} catch(AccountNotFoundException e) {
    if(e.getMessage.equals("User"))
        // do something for User
    else if(e.getMessage.equals("Customer"))
        // do something for Customer
    else
        // do something normal
}
</code></pre>

<p>不管是自定义异常类，还是处理异常的代码，在写代码的时候think twice，可以帮我们解决很多代码中的问题，并优化代码结构。</p>

<p>对于异常处理，多了解一点，受益良多。</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[浅谈 Angular Directive]]></title>
    <link href="http://emalou.me/blog/2014/12/15/simple-angular-directive/"/>
    
    <updated>2014-12-15T20:28:44+08:00</updated>
    <id>http://emalou.me/blog/2014/12/15/simple-angular-directive</id>
    
    <content type="html"><![CDATA[<p>angular directive</p>

<p>angular有很多优良特性，其中很重要的一点是directive
directive,中文翻译是指令。
那么问题来了。。。</p>

<p>问：&#8221;What are Directives?</p>

<p>答：<strong>At a high level, directives are markers on a DOM element (such as an attribute, element name, comment or CSS class) that tell AngularJS&rsquo;s HTML compiler ($compile) to attach a specified behavior to that DOM element or even transform the DOM element and its children.&ldquo;</strong> &ndash; AngularJS 官方文档</p>

<p>问：说人话</p>

<p>答：“从高层次来说，指令是一些页面元素的标记，这些标记能够让angular编译器为该元素添加特殊行为，甚至可以转化改元素和其子元素。”</p>

<p>简而言之 - 为DOM元素添加事件。</p>

<p>问：javascript也可以添加事件，为什么要用directive呢？</p>

<p>答：简单方便，最重要的是重用程度实在是高，比刀耕火种的js要高端大气上档次很多。</p>

<p>问：show me</p>

<p>答：看好了！</p>

<p>html:</p>

<pre><code>&lt;input type="text" valid-check &gt;&lt;/input&gt;
</code></pre>

<p>directive.js:</p>

<pre><code>regApp.directive('validCheck', function(){
  return {
    require: 'ngModel',c
    link: function (scope, element, attr, modelCtrl) {
        modelCtrl.$validators.validCheck = function (modelValue, viewValue) {
            if (!modelCtrl.$isEmpty(viewValue)) {
            if(viewVaule.length !=5)
               return false;
             return true;
            }
        }
    }
}
})
</code></pre>

<p>问：看起来好复杂，求解释</p>

<p>答：第一行定义了一个叫做validCheck的directive，这个东东会返回一个对象，require是这个directive需要绑定的model，link方法里可以定义directive的动作。这个例子中link方法在做验证。通过$validators 对象来给directive绑定验证函数，绑定之后，每次改变输入值都会自动调用验证方法进行验证。modelValue和viewValue分别代表model中的值，和页面上view的值。当viewValue不为空的时候才继续下面的验证。最后返回布尔值。</p>

<p>问：听起来不错，挺好用</p>

<p>答：此处有坑，请注意</p>

<p>问：哦？</p>

<p>答：当link方法返回false的时候，model会变成undefined，model中的方法都不会再执行。意味着false的时候这个input上绑定的方法（ng-change等）都不再执行。初学者要注意这一点
问：总有办法避免吧？</p>

<p>答：聪明！这样写就可以了</p>

<pre><code>&lt;input type="text" valid-check ng-model-options="{allowInvalid: true}"&gt;&lt;/input&gt;
</code></pre>

<p>当然directive还有很多别的用法，例如绑定键盘事件</p>

<pre><code>regApp.directive('numbersOnly', function(){
    return function (scope, element, attrs) {
    element.bind("keypress", function (event) {
        if (event.which &lt; 48 || event.which &gt; 57) {
            scope.$apply(function () {
                scope.$eval(attrs.numbersOnly);
            });
            event.preventDefault();
        }
    });
   };
});
</code></pre>

<p>上面这段代码就只允许用户输入数字。</p>

<p>directive可以作为元素或者属性添加到DOM中，没错，就像<label> 标签，或者class属性一样。
html:</p>

<pre><code>&lt;div error-box &gt;&lt;/div&gt;
</code></pre>

<p>directive.js:</p>

<pre><code>directive('errorBox', function(){
  return {
    restrict: 'A';
    templateUrl: 'error-box.html'
  }
}
</code></pre>

<p>restrict: &lsquo;A&rsquo; 表示可以作为元素属性来应用directive，渲染页面之后error-box.html中的内容会填充到div里。</p>

<p>换一种方式：
html:</p>

<pre><code>&lt;error-box /&gt;
</code></pre>

<p>directive.js:</p>

<pre><code>directive('errorBox', function(){
  return {
    restrict: 'E';
    templateUrl: 'error-box.html'
  }
}
</code></pre>

<p>restrict: &lsquo;E&#8217;则表示你在angular的帮助下创建了一个html标签，渲染页面时error-box.html里的内容会替换掉<error-box/> 这个标签</p>

<p>所以说，Directive功能如此强大，和data-binding一起作为angular的灵魂当之无愧。
有空好好学学。</p>

<p>答：好！</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[使用ssh搭建本地git仓库]]></title>
    <link href="http://emalou.me/blog/2014/11/05/use-ssh-setup-local-git-repo/"/>
    
    <updated>2014-11-05T00:00:00+08:00</updated>
    <id>http://emalou.me/blog/2014/11/05/use-ssh-setup-local-git-repo</id>
    
    <content type="html"><![CDATA[<p>最近由于工作需要，笔者准备在本地局域网中搭建git库，经过授权的本地用户就可以在该库上进行提交，展开工作。</p>

<p>搭建git库很简单，选一台机器作为本地git服务器，建好文件夹，运行</p>

<pre><code>git init
</code></pre>

<p>现在问题来了，如何进行授权。</p>

<p>我们都知道文件传输需要文件传输协议，git pull，git push本质上也都是在进行文件操作，这也是一种文件传输。</p>

<p>常用的传输协议有 http, ssh 等，笔者本次使用了ssh作为传输协议。</p>

<p>在本地ssh目录下有一些成对的key，选择其中一个公钥（以.pub结尾的文件），将文件中的内容append到服务器的ssh目录下，一个叫authticate的文件中。</p>

<p>顾名思义，这个文件是用来授权用户的，加进公钥后表明服务器跟clint机器建通过ssh协议建立了连接。但是这还不够。ssh协议的使用是通过一对秘钥进行工作的，公钥是锁，私钥则相当于钥匙。上一步的操作是把锁给了服务器，那么下一步就要指定开这把锁的钥匙。</p>

<p>client机器上，同样是.ssh目录下，在config文件（如果没有就touch一个）里配置</p>

<pre><code>Hostname 10.29.*.**
IdentityFile ~/.ssh/local_git
</code></pre>

<p>Hostname是服务器的IP，IdentityFile是每次跟这台服务器通信时需要的私钥。</p>

<p>至此，就可以在client机器上git clone 服务器上的代码了。</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[使用Octopress搭建博客的那些坑]]></title>
    <link href="http://emalou.me/blog/2014/10/15/octopress-plus-github-plus-private-domain/"/>
    
    <updated>2014-10-15T17:55:54+08:00</updated>
    <id>http://emalou.me/blog/2014/10/15/octopress-plus-github-plus-private-domain</id>
    
    <content type="html"><![CDATA[<p>最近用octopress和github page搭建了一个简单的个人博客，跟自己的域名绑定起来。
搭建方法google一抓一大把，这里就简要赘述一下这个过程中遇到的几个坑吧。</p>

<hr />

<p><br></p>

<h3>一号坑: 企图手动去改octopress的模板发现改错了</h3>

<p><a href="http://octopress.org/">octopress</a>是用rails写的一款快速搭建博客的工具.
源码使用markdown和scss编写，在部署前用以下命令自动生成html，css等静态网页：</p>

<pre><code>rake generate
</code></pre>

<p>这里就有两个概念了：<strong>源代码</strong> &amp; <strong>部署代码</strong>。
clone过<a href="https://github.com/imathis/octopress">octopress的代码</a>到本地后，cd到该目录下</p>

<p><img src="http://emalou.me/images/octopressDir.png"></p>

<p>会发现有一个source和_deploy的目录，这两个目录下分别存放着上面提到的两个概念中的代码。</p>

<p>上面提到了，octopress中需要手动编写的代码是源码，所以需要改动代码的时候，或者发表博文，所有的修改都应该在这个目录下进行。
而非修改_deploy目录下的html，css等.</p>

<p>修改结束用，在本地使用</p>

<pre><code>rake generate
</code></pre>

<p>生成部署所需的静态网页代码后，</p>

<pre><code>rake preview
</code></pre>

<p>运行以上命令，就可以在本地localhost：4000 查看修改结果了。</p>

<h3>二号坑： 绑定域名的时候CNAME无法提交到github</h3>

<p>我们都知道，使用github page来搭建博客，当需要绑定独立域名时，<br>
只要在该repo下添加CNAME文件，并将独立域名写进去再提交，就绑定成功了。<br></p>

<p>笔者按照常用方法添加CNAME后，却发现无法提交到github上。<br>
那么问题来了，如果说部署所需的所有代码都是先放到source目录下，再由rake generate生成部署代码，那这个CNAME文件怎么办？<br></p>

<p>既然所有部署代码都来源于source目录，那当然是把CNAME文件也放在source目录下了！<br>
此时rake generate后，会发现CNAME文件已经乖乖到了_deploy目录下。<br>
rake deploy 部署后就可以在自己的独立域名下看到github上的博客啦</p>

<p>最后，不要忘记提交代码到github的repo上，记住是提交到source这个branch的。
因为默认master是存放部署代码的，那么source就用来存放我们手写的源码。</p>

<hr />

<p><br>
笔者接触octopress时日不多，隐约感觉rakefile是一个很重要的东西，但由于时间关系还未完全吃透其中的命令。
理解上存在偏差的地方，欢迎指正。</p>
]]></content>
    
  </entry>
  
</feed>